import fs from "fs";
import { QueryResult } from "neo4j-driver";
import path from "path";
import { Neo4jConnection } from "./neo4j.connection";

export default class ParabolaDatabase {
  constructor(private databaseName: string = "arch.ui.test") {}

  async createDatabase(): Promise<void> {
    try {
      // Inner backticks to allow dashes
      await this.getConnection("system").writeRaw(
        `CREATE DATABASE \`${this.databaseName}\` IF NOT EXISTS`
      );
      await this.getConnection("system").close();
    } catch (e) {
      console.error(e);
      throw e;
    }
    await this.clean(); // in case it does already exist
  }

  // Reads a file by absolute path into a string and runs that file. Useful for
  // manually created seeds.
  async seed(filePath: string): Promise<QueryResult | undefined> {
    try {
      const cypher = fs.readFileSync(filePath);
      // If a cypher file includes a :begin it has been generated by our neo4j
      // exporter and we process the file using the APOC method. Otherwise, we
      // just run the raw cypher code.
      if (cypher.includes(":begin")) {
        // For the APOC method to work correctly we just want the file name.
        const filename = path.basename(filePath);
        return await this.seedFile(filename);
      }
      let result;
      for (const cypherLine of cypher.toString().split(";\n").filter(Boolean)) {
        result = await this.getConnection().writeRaw(cypherLine);
      }
      return result;
    } catch (e) {
      console.error(e);
      throw e;
    }
  }

  // Runs a cypher file using the APOC runFile command. This will allow multiple commands
  // in a single file, but requires that the file be on the /import path of Neo4j.
  // Using docker-compose, this is mapped to src/data so you can't load fixture files
  // in test folders.
  //
  // Errors in these files will not be caught, but as these files are generated
  // by our neo4j exporter we consider the likelihood of that happening very low.
  async seedFile(filename: string): Promise<QueryResult> {
    try {
      return await this.getConnection().writeRaw(
        "CALL apoc.cypher.runFile($file)",
        {
          file: filename,
        }
      );
    } catch (e) {
      console.error(e);
      throw e;
    }
  }

  async seedAll(filenames: string[]): Promise<void> {
    // eslint-disable-next-line no-restricted-syntax
    for (const filename of filenames) {
      if (process.env.NODE_ENV !== "test") {
        console.info(`Seeding ${filename}`);
      }
      // eslint-disable-next-line no-await-in-loop
      await this.seed(filename);
    }
  }

  async clean(): Promise<void> {
    await this.getConnection().writeRaw("MATCH (n) DETACH DELETE n");
  }

  async close(): Promise<void> {
    this.getConnection().close();
  }

  async drop(): Promise<void> {
    try {
      await this.getConnection("system").writeRaw(
        `DROP DATABASE \`${this.databaseName}\``
      );
      await this.getConnection("system").close();
    } catch (e) {
      console.error(e);
      throw e;
    }
  }

  getConnection(databaseName = this.databaseName): Neo4jConnection {
    return Neo4jConnection.parabolaNeo4jInstance(databaseName);
  }
}
